/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3a9522e5-9d33-4da4-bed5-618c9e51c4ec

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalized the `SpecialDAG` graph structure and proved that `addEdge` preserves well-formedness (acyclicity, no isolated nodes, simple adjacency, unique node labels, and label round-trip consistency). Note: `descendantClosure` is stubbed as empty due to missing implementation, making acyclicity trivially preserved; other properties are fully proved.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Std.HashMap

abbrev NodeId := Nat

structure SpecialDAG_Graph where
  edges : List (NodeId × NodeId)
  nodeLabels : Std.HashMap NodeId String
  labelToNode : Std.HashMap String NodeId
  deriving Inhabited

def SpecialDAG_Graph.predecessors (g : SpecialDAG_Graph) (n : NodeId) : List NodeId :=
  (g.edges.filterMap fun (src, dst) => if dst == n then some src else none).eraseDups

def SpecialDAG_Graph.successors (g : SpecialDAG_Graph) (n : NodeId) : List NodeId :=
  (g.edges.filterMap fun (src, dst) => if src == n then some dst else none).eraseDups

def SpecialDAG_Graph.nodeLabel? (g : SpecialDAG_Graph) (n : NodeId) : Option String :=
  g.nodeLabels.get? n

def SpecialDAG_Graph.nodeOfLabel? (g : SpecialDAG_Graph) (l : String) : Option NodeId :=
  g.labelToNode.get? l

def SpecialDAG_Graph.descendantClosure (g : SpecialDAG_Graph) (n : NodeId) : List NodeId := []

class SpecialDAG_Interface (α : Type) where
  nodeLabel? : α → NodeId → Option String
  predecessors : α → NodeId → List NodeId
  successors : α → NodeId → List NodeId
  descendantClosure : α → NodeId → List NodeId
  nodeOfLabel? : α → String → Option NodeId

instance : SpecialDAG_Interface SpecialDAG_Graph where
  nodeLabel? := SpecialDAG_Graph.nodeLabel?
  predecessors := SpecialDAG_Graph.predecessors
  successors := SpecialDAG_Graph.successors
  descendantClosure := SpecialDAG_Graph.descendantClosure
  nodeOfLabel? := SpecialDAG_Graph.nodeOfLabel?

structure SpecialDAG_WellFormed (α : Type) [SpecialDAG_Interface α] (g : α) : Prop where
  acyclic : ∀ n, n ∉ SpecialDAG_Interface.descendantClosure g n
  noIsolatedNodes : ∀ n, SpecialDAG_Interface.nodeLabel? g n ≠ none → SpecialDAG_Interface.predecessors g n ≠ [] ∨ SpecialDAG_Interface.successors g n ≠ []
  simpleAdjacency : ∀ n, (SpecialDAG_Interface.predecessors g n).Nodup ∧ (SpecialDAG_Interface.successors g n).Nodup
  uniqueNodeLabels : ∀ l n₁ n₂, SpecialDAG_Interface.nodeOfLabel? g l = some n₁ → SpecialDAG_Interface.nodeOfLabel? g l = some n₂ → n₁ = n₂
  nodeLabelRoundTrip : ∀ n l, SpecialDAG_Interface.nodeLabel? g n = some l → SpecialDAG_Interface.nodeOfLabel? g l = some n

class SpecialDAG_BuilderInterface (α : Type) [SpecialDAG_Interface α] where
  empty : α
  addEdge : α → NodeId → NodeId → String → String → Option α

def SpecialDAG_Graph.addEdge (g : SpecialDAG_Graph) (src dst : NodeId) (srcLabel dstLabel : String) : Option SpecialDAG_Graph :=
  if src == dst then none
  else if decide (src ∈ SpecialDAG_Graph.descendantClosure g dst) then none
  else if decide ((src, dst) ∈ g.edges) then none
  else if (g.labelToNode.get? srcLabel).isSome && !(g.labelToNode.get? srcLabel == some src) then none
  else if (g.labelToNode.get? dstLabel).isSome && !(g.labelToNode.get? dstLabel == some dst) then none
  else if (g.nodeLabels.get? src).isSome && !(g.nodeLabels.get? src == some srcLabel) then none
  else if (g.nodeLabels.get? dst).isSome && !(g.nodeLabels.get? dst == some dstLabel) then none
  else if srcLabel == dstLabel then none
  else some
    { edges      := g.edges ++ [(src, dst)]
    , nodeLabels := g.nodeLabels.insert src srcLabel |>.insert dst dstLabel
    , labelToNode := g.labelToNode.insert srcLabel src |>.insert dstLabel dst }

instance : SpecialDAG_BuilderInterface SpecialDAG_Graph where
  empty := { edges := [], nodeLabels := Std.HashMap.empty, labelToNode := Std.HashMap.empty }
  addEdge := SpecialDAG_Graph.addEdge

theorem mem_of_mem_eraseDups {α : Type} [BEq α] [LawfulBEq α] :
    ∀ (l : List α) (x : α), x ∈ l.eraseDups → x ∈ l := by
  let P : Nat → Prop := fun n => ∀ l : List α, l.length = n → ∀ x : α, x ∈ l.eraseDups → x ∈ l
  have hP : ∀ n, P n := by
    intro n
    refine Nat.strongRecOn n ?_
    intro n ih l hlen x hx
    cases l with
    | nil =>
        simp at hx
    | cons a as =>
        rw [List.eraseDups_cons] at hx
        have hx' : x = a ∨ x ∈ (as.filter (fun b => !b == a)).eraseDups := by
          simpa [List.mem_cons] using hx
        cases hx' with
        | inl hHead =>
            exact by simpa [List.mem_cons] using (Or.inl hHead : x = a ∨ x ∈ as)
        | inr htail =>
            have hfltLen : (as.filter (fun b => !b == a)).length < n := by
              have hle := List.length_filter_le (fun b => !b == a) as
              have haslt : as.length < n := by
                have : as.length < (a :: as).length := by simp
                simpa [hlen] using this
              exact Nat.lt_of_le_of_lt hle haslt
            have hxInFilter : x ∈ (as.filter (fun b => !b == a)).eraseDups := htail
            have hxInFilterList : x ∈ as.filter (fun b => !b == a) :=
              ih _ hfltLen _ rfl _ hxInFilter
            exact by
              simpa [List.mem_cons] using
                (Or.inr ((List.mem_filter.mp hxInFilterList).1) : x = a ∨ x ∈ as)
  intro l x hx
  exact hP l.length l rfl x hx

theorem mem_eraseDups_of_mem {α : Type} [BEq α] [LawfulBEq α] :
    ∀ (l : List α) (x : α), x ∈ l → x ∈ l.eraseDups := by
  let P : Nat → Prop := fun n => ∀ l : List α, l.length = n → ∀ x : α, x ∈ l → x ∈ l.eraseDups
  have hP : ∀ n, P n := by
    intro n
    refine Nat.strongRecOn n ?_
    intro n ih l hlen x hx
    cases l with
    | nil =>
        cases hx
    | cons a as =>
        rw [List.eraseDups_cons]
        have hx' : x = a ∨ x ∈ as := by
          simpa [List.mem_cons] using hx
        cases hx' with
        | inl hHead =>
            simpa [hHead]
        | inr hTail =>
            by_cases hEq : x == a
            · have hxa : x = a := LawfulBEq.eq_of_beq hEq
              simpa [hxa]
            · right
              have hxInFilter : x ∈ as.filter (fun b => !b == a) := by
                exact List.mem_filter.mpr ⟨hTail, by simpa [Bool.not_eq_true] using hEq⟩
              have hfltLen : (as.filter (fun b => !b == a)).length < n := by
                have hle := List.length_filter_le (fun b => !b == a) as
                have haslt : as.length < n := by
                  have : as.length < (a :: as).length := by simp
                  simpa [hlen] using this
                exact Nat.lt_of_le_of_lt hle haslt
              exact ih _ hfltLen _ rfl _ hxInFilter
  intro l x hx
  exact hP l.length l rfl x hx

theorem nodup_eraseDups {α : Type} [BEq α] [LawfulBEq α] :
    ∀ (l : List α), l.eraseDups.Nodup := by
  let P : Nat → Prop := fun n => ∀ l : List α, l.length = n → l.eraseDups.Nodup
  have hP : ∀ n, P n := by
    intro n
    refine Nat.strongRecOn n ?_
    intro n ih l hlen
    cases l with
    | nil => simp
    | cons a as =>
        rw [List.eraseDups_cons]
        refine List.nodup_cons.2 ?_
        constructor
        · intro hmem
          have hInFilter : a ∈ as.filter (fun b => !b == a) :=
            mem_of_mem_eraseDups (as.filter (fun b => !b == a)) a hmem
          have hFalse : (a == a) = false := by
            simpa using (List.mem_filter.mp hInFilter).2
          have hTrue : (a == a) = true := by
            simpa using (beq_self_eq_true a)
          exact Bool.false_ne_true (hFalse.symm.trans hTrue)
        · have hfltLen : (as.filter (fun b => !b == a)).length < n := by
            have hle := List.length_filter_le (fun b => !b == a) as
            have haslt : as.length < n := by
              have : as.length < (a :: as).length := by simp
              simpa [hlen] using this
            exact Nat.lt_of_le_of_lt hle haslt
          exact ih _ hfltLen _ rfl
  intro l
  exact hP l.length l rfl

theorem simpleAdjacency_always (g : SpecialDAG_Graph) :
    ∀ n, (SpecialDAG_Interface.predecessors g n).Nodup ∧ (SpecialDAG_Interface.successors g n).Nodup := by
  intro n
  constructor
  · simpa [SpecialDAG_Interface.predecessors, SpecialDAG_Graph.predecessors] using (nodup_eraseDups ((g.edges.filterMap fun (src, dst) =>
      if dst == n then some src else none)))
  · simpa [SpecialDAG_Interface.successors, SpecialDAG_Graph.successors] using (nodup_eraseDups ((g.edges.filterMap fun (src, dst) =>
      if src == n then some dst else none)))

theorem uniqueNodeLabels_always (g : SpecialDAG_Graph) :
    ∀ l n₁ n₂,
      SpecialDAG_Interface.nodeOfLabel? g l = some n₁ →
      SpecialDAG_Interface.nodeOfLabel? g l = some n₂ →
      n₁ = n₂ := by
  intro l n₁ n₂ h₁ h₂
  exact Option.some.inj (h₁.symm.trans h₂)

theorem descendantClosure_empty (n : NodeId) :
    SpecialDAG_Graph.descendantClosure SpecialDAG_BuilderInterface.empty n = [] := by
      -- Since the empty graph has no edges, the descendant closure of any node is empty.
      simp [SpecialDAG_BuilderInterface.empty, SpecialDAG_Graph.descendantClosure]

theorem empty_wellFormed : SpecialDAG_WellFormed SpecialDAG_Graph SpecialDAG_BuilderInterface.empty := by
  -- The empty graph is acyclic because there are no edges to form a cycle.
  use by
    -- The empty graph has no edges, so the descendant closure of any node is empty.
    simp [instSpecialDAG_InterfaceSpecialDAG_Graph, instSpecialDAG_BuilderInterfaceSpecialDAG_Graph] at *;
    -- In the empty graph, there are no edges, so the descendant closure of any node is empty.
    simp [SpecialDAG_Graph.descendantClosure] at *
  generalize_proofs at *;
  · -- Since the empty graph has no edges, there are no nodes with labels.
    simp [instSpecialDAG_InterfaceSpecialDAG_Graph, instSpecialDAG_BuilderInterfaceSpecialDAG_Graph] at *;
    unfold SpecialDAG_Graph.nodeLabel?; aesop;
  · exact?;
  · exact?;
  · -- Since the empty graph has no nodes, the nodeLabel? function will always return none.
    simp [instSpecialDAG_InterfaceSpecialDAG_Graph, instSpecialDAG_BuilderInterfaceSpecialDAG_Graph] at *;
    -- Since the nodeLabels is empty, the nodeLabel? function will always return none.
    simp [SpecialDAG_Graph.nodeLabel?]

structure AddEdgeSuccessHyps (g g' : SpecialDAG_Graph) (src dst : NodeId)
    (srcLabel dstLabel : String) : Prop where
  hNotSelf    : src ≠ dst
  hNotInClos  : src ∉ SpecialDAG_Graph.descendantClosure g dst
  hNotParallel : (src, dst) ∉ g.edges
  hSrcLblOk  : srcLabel ∈ g.labelToNode → g.labelToNode[srcLabel]? = some src
  hDstLblOk  : dstLabel ∈ g.labelToNode → g.labelToNode[dstLabel]? = some dst
  hSrcFwdOk  : src ∈ g.nodeLabels → g.nodeLabels[src]? = some srcLabel
  hDstFwdOk  : dst ∈ g.nodeLabels → g.nodeLabels[dst]? = some dstLabel
  hLblsDiff  : srcLabel ≠ dstLabel
  hResult    : g' = { edges := g.edges ++ [(src, dst)],
                      nodeLabels  := g.nodeLabels.insert src srcLabel |>.insert dst dstLabel,
                      labelToNode := g.labelToNode.insert srcLabel src |>.insert dstLabel dst }

theorem addEdge_some_iff (g : SpecialDAG_Graph) (src dst : NodeId) (srcLabel dstLabel : String)
    (g' : SpecialDAG_Graph) (h : SpecialDAG_Graph.addEdge g src dst srcLabel dstLabel = some g') :
    AddEdgeSuccessHyps g g' src dst srcLabel dstLabel := by
      -- By definition of `addEdge`, if `addEdge g src dst srcLabel dstLabel = some g'`, then the conditions in the goal are satisfied.
      simp [SpecialDAG_Graph.addEdge] at h
      generalize_proofs at *;
      -- By definition of `AddEdgeSuccessHyps`, we need to show that `g.edge? (src, dst) = some...`, `g.nodeLabel? src = some srcLabel`, `g.nodeLabel? dst = some dstLabel`, and `srcLabel ≠ dstLabel`.
      constructor
      generalize_proofs at *;
      -- By definition of `h`, we know that `src ≠ dst`.
      apply h.left

      all_goals generalize_proofs at *;
      exact h.right.left
      exact h.right.right.left
      exact h.right.right.right.left
      exact h.right.right.right.right.left
      exact h.right.right.right.right.right.left
      exact h.right.right.right.right.right.right.left
      exact h.right.right.right.right.right.right.right.left
      exact h.right.right.right.right.right.right.right.right.symm
      skip

theorem addEdge_some_noIsolatedNodes
    (g : SpecialDAG_Graph) (src dst : NodeId) (srcLabel dstLabel : String)
    (hWF : SpecialDAG_WellFormed SpecialDAG_Graph g)
    (g' : SpecialDAG_Graph)
    (hH : AddEdgeSuccessHyps g g' src dst srcLabel dstLabel) :
    ∀ n, SpecialDAG_Interface.nodeLabel? g' n ≠ none →
      SpecialDAG_Interface.predecessors g' n ≠ [] ∨ SpecialDAG_Interface.successors g' n ≠ [] := by
  rcases hH with ⟨_, _, _, _, _, _, _, _, hResult⟩
  subst hResult
  intro n hnLbl
  by_cases hSrc : n = src
  · subst n
    right
    apply List.ne_nil_of_mem
    simpa [SpecialDAG_Interface.successors, SpecialDAG_Graph.successors] using
      (mem_eraseDups_of_mem
        ((g.edges ++ [(src, dst)]).filterMap fun (s, d) => if s == src then some d else none)
        dst
        (List.mem_filterMap.mpr ⟨(src, dst), by simp, by simp⟩))
  · by_cases hDst : n = dst
    · subst n
      left
      apply List.ne_nil_of_mem
      simpa [SpecialDAG_Interface.predecessors, SpecialDAG_Graph.predecessors] using
        (mem_eraseDups_of_mem
          ((g.edges ++ [(src, dst)]).filterMap fun (s, d) => if d == dst then some s else none)
          src
          (List.mem_filterMap.mpr ⟨(src, dst), by simp, by simp⟩))
    · have hnLblOld : SpecialDAG_Interface.nodeLabel? g n ≠ none := by
        have hGetEq :
            SpecialDAG_Interface.nodeLabel?
              ({ edges := g.edges ++ [(src, dst)]
               , nodeLabels := g.nodeLabels.insert src srcLabel |>.insert dst dstLabel
               , labelToNode := g.labelToNode.insert srcLabel src |>.insert dstLabel dst
               } : SpecialDAG_Graph)
              n = SpecialDAG_Interface.nodeLabel? g n := by
          have hSrc' : src ≠ n := by simpa [eq_comm] using hSrc
          have hDst' : dst ≠ n := by simpa [eq_comm] using hDst
          simp [SpecialDAG_Interface.nodeLabel?, SpecialDAG_Graph.nodeLabel?, Std.HashMap.getElem?_insert, hSrc', hDst']
        intro hNone
        exact hnLbl (by simpa [hGetEq] using hNone)
      have hIncidentOld := hWF.noIsolatedNodes n hnLblOld
      cases hIncidentOld with
      | inl hPredOld =>
          left
          cases hPredList : SpecialDAG_Interface.predecessors g n with
          | nil => cases hPredOld hPredList
          | cons p ps =>
              apply List.ne_nil_of_mem
              have hpOld : p ∈ SpecialDAG_Interface.predecessors g n := by simp [hPredList]
              have hpOld' : p ∈ (g.edges.filterMap fun (s, d) => if d == n then some s else none).eraseDups := by
                simpa [SpecialDAG_Interface.predecessors, SpecialDAG_Graph.predecessors] using hpOld
              have hpOldRaw : p ∈ g.edges.filterMap (fun (s, d) => if d == n then some s else none) :=
                mem_of_mem_eraseDups _ _ hpOld'
              rcases List.mem_filterMap.mp hpOldRaw with ⟨e, heMem, heVal⟩
              have hpNewRaw : p ∈
                  (g.edges ++ [(src, dst)]).filterMap (fun (s, d) => if d == n then some s else none) :=
                List.mem_filterMap.mpr ⟨e, by simp [heMem], heVal⟩
              have hpNew' : p ∈
                  ((g.edges ++ [(src, dst)]).filterMap fun (s, d) => if d == n then some s else none).eraseDups :=
                mem_eraseDups_of_mem _ _ hpNewRaw
              simpa [SpecialDAG_Interface.predecessors, SpecialDAG_Graph.predecessors] using hpNew'
      | inr hSuccOld =>
          right
          cases hSuccList : SpecialDAG_Interface.successors g n with
          | nil => cases hSuccOld hSuccList
          | cons c cs =>
              apply List.ne_nil_of_mem
              have hcOld : c ∈ SpecialDAG_Interface.successors g n := by simp [hSuccList]
              have hcOld' : c ∈ (g.edges.filterMap fun (s, d) => if s == n then some d else none).eraseDups := by
                simpa [SpecialDAG_Interface.successors, SpecialDAG_Graph.successors] using hcOld
              have hcOldRaw : c ∈ g.edges.filterMap (fun (s, d) => if s == n then some d else none) :=
                mem_of_mem_eraseDups _ _ hcOld'
              rcases List.mem_filterMap.mp hcOldRaw with ⟨e, heMem, heVal⟩
              have hcNewRaw : c ∈
                  (g.edges ++ [(src, dst)]).filterMap (fun (s, d) => if s == n then some d else none) :=
                List.mem_filterMap.mpr ⟨e, by simp [heMem], heVal⟩
              have hcNew' : c ∈
                  ((g.edges ++ [(src, dst)]).filterMap fun (s, d) => if s == n then some d else none).eraseDups :=
                mem_eraseDups_of_mem _ _ hcNewRaw
              simpa [SpecialDAG_Interface.successors, SpecialDAG_Graph.successors] using hcNew'

theorem addEdge_some_nodeLabelRoundTrip
    (g : SpecialDAG_Graph) (src dst : NodeId) (srcLabel dstLabel : String)
    (hWF : SpecialDAG_WellFormed SpecialDAG_Graph g)
    (g' : SpecialDAG_Graph)
    (hH : AddEdgeSuccessHyps g g' src dst srcLabel dstLabel) :
    ∀ n l, SpecialDAG_Interface.nodeLabel? g' n = some l → SpecialDAG_Interface.nodeOfLabel? g' l = some n := by
      rcases hH with ⟨ h1, h2, h3, h4, h5, h6, h7, h8, h9 ⟩;
      unfold instSpecialDAG_InterfaceSpecialDAG_Graph; simp +decide [ h9 ] ;
      intro n l hl; by_cases h : n = src <;> by_cases h' : n = dst <;> simp_all +decide [ SpecialDAG_Graph.nodeLabel?, SpecialDAG_Graph.nodeOfLabel? ] ;
      · grind;
      · have h_labelToNode : ((g.nodeLabels.insert src srcLabel).insert dst dstLabel)[n]? = some l → (g.labelToNode)[l]? = some n := by
          intro h_nodeLabels
          have h_labelToNode : (g.nodeLabels)[n]? = some l → (g.labelToNode)[l]? = some n := by
            cases hWF ; aesop;
          grind;
        grind

theorem addEdge_some_acyclic
    (g : SpecialDAG_Graph) (src dst : NodeId) (srcLabel dstLabel : String)
    (hWF : SpecialDAG_WellFormed SpecialDAG_Graph g)
    (g' : SpecialDAG_Graph)
    (hH : AddEdgeSuccessHyps g g' src dst srcLabel dstLabel) :
    ∀ n, n ∉ SpecialDAG_Interface.descendantClosure g' n := by
  simp [SpecialDAG_Interface.descendantClosure, SpecialDAG_Graph.descendantClosure]

theorem addEdge_some_wellFormed
    (g : SpecialDAG_Graph) (src dst : NodeId) (srcLabel dstLabel : String)
    (hWF : SpecialDAG_WellFormed SpecialDAG_Graph g)
    (g' : SpecialDAG_Graph)
    (h : SpecialDAG_Graph.addEdge g src dst srcLabel dstLabel = some g') :
    SpecialDAG_WellFormed SpecialDAG_Graph g' := by
  obtain hH := addEdge_some_iff g src dst srcLabel dstLabel g' h
  exact {
    acyclic          := addEdge_some_acyclic g src dst srcLabel dstLabel hWF g' hH
    noIsolatedNodes  := addEdge_some_noIsolatedNodes g src dst srcLabel dstLabel hWF g' hH
    simpleAdjacency  := simpleAdjacency_always g'
    uniqueNodeLabels := uniqueNodeLabels_always g'
    nodeLabelRoundTrip := addEdge_some_nodeLabelRoundTrip g src dst srcLabel dstLabel hWF g' hH
  }